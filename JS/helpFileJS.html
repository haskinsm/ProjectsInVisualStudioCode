<!DOCTYPE html>
<!-- 
    In VisualStudioCode remember can multiline edit by holding alt and clicking
    -To debug need to open live server (right click) then click run debug against local host (may need to change stuff like the url in launch.json file).
     console.log() outputs will then be visible in the dbeug console 
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base JS help file</title>
    <!-- Loading simple scipts -->
    <script src="myscript.js"></script>
</head>
<body>
    <button id='btnClick' onclick="sayYup();"> Click here to run a JS file </button>
    <br>
    <script>
        document.write("Hello, World!!"); // Simple statement. Remember to add ';' at end of each line

    // Accessing Html elements 
       //const obj = getElementById("demo")

    // Variables
        var myvariable; // var declaration. Weakly typed -> dont declare type
        myvariable = 5;
        myvariable ++; // myv == 6
        mytotal = myvariable ++; // myv == 7, total == 6   --> increment here does not take effect on total as after myvar 
        mytotal = ++ myvariable; // myv == 8, total == 8   --> increment here takes effect on total as before myvar
        document.write("<br>" + myvariable);
        document.write("<br>", mytotal);

        var othervariable = false;
        var x; // value of x is undefined
        var y = undefined; // we can also set the value of a variable as undefined
        var z = null;

        typeof "John Doe" // Returns "string"
        typeof 3.14 // Returns "number"
        typeof true // Returns "boolean"
        typeof 234567890123456789012345678901234567890n // Returns bigint
        typeof undefined // Returns "undefined"
        typeof null // Returns "object" (kind of a bug in JavaScript)

        // Collection of data in key-value pairs
        var obj1 = {
            x:  43,
            y:  "Hello world!",
            z: function(){
                return this.x;
            }
        } 
       
    // Implicit Type Coercion (JS is weakly typed)
        // String coercion
        // With + operator (converts int type to string and concatenates)
        var x = 3
        var y = "3" 
        x + y //Returns "33"
        // global method Number() can convert strings to numbers.
        x + Number(y) // == 6
        // global method String() can convert numbers to strings. So can (<num>).toString()
        var x = 24;
        var y = "Hello";
        x + y   // Returns "24Hello";  
        // With - operator (converts string type to int and subtracts) Same goes with * and I think the other operators 
        var x = 3;
        var y = "3";
        x - y    //Returns 0 since the variable y (string type) is converted to a number type
        "5" * "2"   // returns 10        because "5" and "2" are converted to 5 and 2

        // Boolean Coercion 
        // Truthy values are those which will be converted (coerced) to true . Falsy values are those which will be converted to false .
        // All values except 0, 0n, -0, “”, null, undefined and NaN are truthy values.
        var x = 0;
        var y = 23;    
        if(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)       
        if(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy)
        
        var x = 220;
        var y = "Hello";
        var z = undefined;       
        x || y    // Returns 220 since the first value is truthy      
        x || z   // Returns 220 since the first value is truthy        
        x && y    // Returns "Hello" since both the values are truthy       
        y && z   // Returns undefined since the second value is falsy     
        if( x && y ){ 
            console.log("Code runs" ); // This block runs because x && y returns "Hello" (Truthy)
            // console. log() is a function in JavaScript which is used to print any kind of variables
            // defined before in it or to just print any message that needs to be displayed to the user.
        }         
        if( x || z ){
            console.log("Code runs");  // This block runs because x || y returns 220(Truthy)
        }

        // Equality Coercion
        // The ‘ == ‘ operator compares values and not types. The ‘==’ operator, converts both the operands to the same type and then compares them.
        var a = 12;
        var b = "12";
        a == b // Returns true because both 'a' and 'b' are converted to the same type and then compared. Hence the operands are equal.

        // Coercion does not take place when using the ‘===’ operator. Both operands are not converted to the same type in the case of ‘===’ operator.
        var a = 226;
        var b = "226";
        a === b // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal.

    // Dates 
        d = new Date()
        d.getTime() // returns 1404568027739
        String(Date())  // returns "Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)"
        Date().toString()  // returns "Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)"

    // NaN property in JS
        isNaN("Hello")  // Returns true
        isNaN(345)   // Returns false
        isNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number) 
        isNaN(true) // Returns false, since true converted to Number type results in 1 ( a number) ***********
        isNaN(false) // Returns false ***********
        isNaN(undefined) // Returns true

    // Assignment Operator ('=')
        // For primitive Data types
        var y = 234;
        var z = y;
        // Changing the value of y
        y = 23;
        console.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z

        // For non-primitive data types
        var obj = { name: "Vivek", surname: "Bisht" };
        var obj2 = obj;
        // changing the value of obj1
        obj1.name = "Akki";
        console.log(obj2);       
        // Returns {name:"Akki", surname:"Bisht"} since both the variables are pointing to the same address.


    // Concat Strings
        var words = "Can the real slim shady";
        var moreWords = "please stand up";
        var sentence = words + " " + moreWords
        document.write("<br>", sentence); // Adds two strings with a space in between

    // Vars are stored as objects in JS and can access some properties of the objects
        var alpha = "ABCDEFG";
        var length = alpha.length;
        var numbers = 1289999
        // var length = numbers.length // Cannot do this with numbers 
        document.write("<br>", length);
        var result = alpha.substring(3, 5); // Gets DE, does not include element at index 5
        document.write("<br>", result);

    // Arrays
        var a = new Array(4); // array that will hold 4 items
        a[0] = "cat";
        a[1] = "dog";
        a[2] = 95;
        a[3] = true;
        document.write("<br>", a[1]);
           // or create like so 
        var b = new Array("cat", "dog", 95, true);
        document.write("<br>", b[3]);
            // or
        var c = ["cat", "dog", 95, true];

    // conditions
        var a = 7;
        if (a>10) {
            alert("A is smaller or equal to 10. A is " + a); // sends a JS alert and out puts the var 
        } else{
            // alert("A is greater than 10. A is " + a);
        }

    // Loops 
        for (i=0; i<5; i++) {
            document.write("<br>" + "This is iteration " + i)
        }

     // Operators
        var x = 2;
        var y = "2";
        console.log(x == y);  // Returns true since the value of both x and y is the same
        console.log(x === y); // Returns false since the typeof x is "number" and typeof y is "string"

    // Functions
        function sayHello(who){
            document.write("<br>", "Hello, " + who);
            // Can put these in the head section to tidy things up 
        }
        sayHello("Fred");

        // Immediately invoked function (known as IIFE) is a function that runs as soon as it is defined  ****** V Imp.
        // Syntax of IIFE :
        (function(){ 
            // Do something;
            var foo = "Hello There this is coming from my IIFE";
            console.log(foo);
        })();
        // Need the first set of parentheses as otherwise the complier will throw an error as functions need a name in JS
        // not a function declaration, instead, it’s a function expression.
        // Second set of parentheses results in the function declaration being returned immediately. 

        // The primary reason to use an IIFE is to obtain data privacy. Because JavaScript’s var scopes variables to their containing function, 
        // any variables declared within the IIFE cannot be accessed by the outside world.

        // Higher order functions 
        // Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions
        function higherOrder(fn) {
          fn();
        }
            
        higherOrder(function() { console.log("Hello world") }); 

        function higherOrder2() {
            return function() {
                return "Do something";
            }
        }
        var x = higherOrder2();
        x()   // Returns "Do something"


    // Constructor Function
        // Constructor functions are used to create objects in javascript.
        // **Note- Name of a constructor function should always be written in Pascal Notation: every word should start with a capital letter.
        function Person(name,age,gender){
            this.name = name;
            this.age = age;
            this.gender = gender;
        }


        var person1 = new Person("Vivek", 76, "male");
        console.log(person1);

        var person2 = new Person("Courtney", 34, "female");
        console.log(person2);


    // Callbacks
        // A callback is a function that will be executed after another function gets executed.
        // In javascript, a callback is simply a function that is passed to another function as a parameter and is invoked or executed inside the other function.
        // In javascript, functions are treated as first-class citizens, they can be used as an argument of another function, can be returned by another function 
        // and can be used as a property of an object.

        // Functions that are used as an argument to another function are called callback functions.
        function divideByHalf(sum){
          console.log(Math.floor(sum / 2));
        }

        function multiplyBy2(sum){
          console.log(sum * 2);
        }

        function operationOnSum(num1,num2,operation){
          var sum = num1 + num2;
          operation(sum); // The callback. Both divideByHalf and multiplyBy2 functions are used as callback functions 
        }

        operationOnSum(3, 3, divideByHalf); // Outputs 3
        operationOnSum(5, 5, multiplyBy2); // Outputs 20 

    // Promises 
        // what will happen if your code will have callbacks within callbacks within callbacks and it goes on. Well, this recursive structure of callback is called
        // as ‘callback hell’ and promises help to solve this kind of issue. Promises are useful in asynchronous javascript operation when we need to execute two or
        // more back to back operations (or chaining callback), where each subsequent function starts when the previous one is completed. A promise is an object that 
        // may produce a single value some time in the future, either a resolved value or a reason that it’s not resolved (rejected). 

        // Promises resolve the issue of ‘callback hell’ which is nothing but a recursive structure of callbacks (callbacks within callbacks within callbacks and so forth).
        // A Promise may be in three possible states…
        // Fulfilled: When the operation is completed successfully.
        // Rejected: When the operation is failed.
        // Pending: initial state, neither fulfilled nor rejected.

        const wait = time => new Promise((resolve) => setTimeout(resolve, time));

        wait(3000).then(() => console.log('Hello!')); // 'Hello!'
        // Our wait(3000) call will wait 3000ms (3 seconds), and then log 'Hello!'. All spec-compatible promises define a .then() method which you use to pass
        // handlers which can take the resolved or rejected value.

    // Async & Await 
        // Stop and wait until something is resolved. Async & await just syntactic sugar on top of Promises and like promises it also provides a way to maintain 
        // asynchronous operation more synchronously. So in javascript asynchronous operation can be handled in various versions…
        // ES5 -> Callback
        // ES6 -> Promise
        // ES7 -> async & await
        // You can use Async/await to perform the Rest API request where you want the data to fully load before pushing it to the view. 
        // For Nodejs and browser programmers async/await is a great syntactic improvement. It helps the developer to implement functional programming in javascript 
        // and it also increases the code readability.

        const showPosts = async () => {
          const response = await fetch('https://jsonplaceholder.typicode.com/posts');
          const posts = await response.json();
          console.log(posts);
        }
        showPosts();
        // To notify JS that we are working with promises we need to wrap ‘await’ inside an ‘async’ function. In the above example, we (a)wait for two things: 
        // response and posts. Before we can convert the response to JSON format, we need to make sure we have the response fetched, otherwise we can end up converting
        // a response that is not there yet, which will most likely prompt an error.
        

    // This Keyword
        // The “this” keyword refers to the object that the function is a property of. ***** I.e. the functuon is in some class or object 
        // The value of “this” keyword will always depend on the object that is invoking the function.
        function doSomething() {
            console.log(this);
        }        
        doSomething();
        // Since the function is invoked in the global context, the function is a property of the global object.
        // Therefore, the output of the above code will be the global object. Since we ran the above code inside the browser, the global object is the window object.

        var obj = {
            name:  "vivek",
            getName: function(){
              console.log(this.name);
            }
        }       
        obj.getName();
        // In the above code, at the time of invocation, the getName function is a property of the object obj , 
        // therefore, the this keyword will refer to the object obj , and hence the output will be “vivek”.

        var obj = {
            name:  "vivek",
            getName: function(){
              console.log(this.name);
            }       
        }
        var getName = obj.getName; //Note this gets the fucntion and does not enact the function
        var obj2 = {name:"akshay", getName }; // note getName is a function, hence you can call it
        obj2.getName();

        // The output will be “akshay”.
        // Although the getName function is declared inside the object obj , at the time of invocation, getName()
        // is a property of obj2 , therefore the “this” keyword will refer to obj2 .

        // The silly way to understanding the this keyword is, whenever the function is invoked, check the object before the dot .
        // The value of this . keyword will always be the object before the dot .

        // If there is no object before the dot like in example1, the value of this keyword will be the global object.

    // Call method
        // It’s a predefined method in javascript.
        // This method invokes a method (function) by specifying the owner object.
        function sayHello(){
            return "Hello " + this.name;
        }     
        var obj = {name: "Sandy"};
        sayHello.call(obj); // Returns "Hello Sandy"
                

        // call() method allows an object to use the method (function) of another object.
        var person = {
            age: 23,
            getAge: function(){
                return this.age;
            }
        }     
        var person2 = {age:  54};
        person.getAge.call(person2);// Returns 54  

        // call() accepts arguments:
        function saySomething(message){
            return this.name + " is " + message;
        }        
        var person4 = {name:  "John"};        
        saySomething.call(person4, "awesome"); // Returns "John is awesome"    

    // apply()
        // The apply method is similar to the call() method. The only difference is that,
        // call() method takes arguments separately whereas, apply() method takes arguments as an array.

        function saySomething(message){
            return this.name + " is " + message;
        }     
        var person4 = {name:  "John"};     
        saySomething.apply(person4, ["awesome"]);

    // bind()
        // This method returns a new function, where the value of “this” keyword will be bound to the owner object, which is provided as a parameter.
        // Example with arguments:
        var bikeDetails = {
            displayDetails: function(registrationNumber,brandName){
                return this.name+ " , "+ "bike details: "+ registrationNumber + " , " + brandName;
            }
        }        
        var person1 = {name:  "Vivek"};       
        var detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, "TS0122", "Bullet");       
        // Binds the displayDetails function to the person1 object         
        detailsOfPerson1();
        // Returns Vivek, bike details: TS0452, Thunderbird 


    // Prototypes in JS
        // All javascript objects inherit properties from a prototype.
        // For example,
        // Date objects inherit properties from the Date prototype
        // Math objects inherit properties from the Math prototype
        // Array objects inherit properties from the Array prototype.
        // On top of the chain is Object.prototype. Every prototype inherits properties and methods from the Object.prototype.

        // A prototype is a blueprint of an object. Prototype allows us to use properties and methods on an object even if the properties
        // and methods do not exist on the current object.
        
        // Let’s see prototypes help us use methods and properties:
        var arr = [];
        arr.push(2);
        arr.push(3);
        arr.push([1,2]);
        arr.push(false);
        console.log(arr); // Outputs array
        // we have not defined any property or method called push on the array “arr” but the javascript engine does not throw an error.
        // The reason being the use of prototypes. As we discussed before, Array objects inherit properties from the Array prototype.

        // The javascript engine sees that the method push does not exist on the current array object and therefore, looks for the method 
        // push inside the Array prototype and it finds the method.
        // Whenever the property or method is not found on the current object, the javascript engine will always try to look in its prototype 
        // and if it still does not exist, it looks inside the prototype's prototype and so on.

        // Example: 
        function Bike(model,color){
          this.model = model,
          this.color = color,
          this.getDetails = function(){
            return this.model+' bike is '+this.color;
          }
        }
        var bikeObj1 = new Bike('BMW','BLACK');
        var bikeObj2 = new Bike('BMW','WHITE');
        console.log(bikeObj1.getDetails()); //output: BMW bike is BLACK
        console.log(bikeObj2.getDetails()); //output: BMW bike is WHITE
        console.log(bikeObj1,bikeObj2);

        // In our example, two objects have two instances of the constructor function getDetails(). It doesn’t make sense having a copy of getDetails
        // doing the same thing.

        // Instead of using a copy of instances, we are going to use the prototype property of a constructor function.

        // When an object is created in JavaScript, JavaScript engine adds a __proto__ property to the newly created object which is called 
        // dunder proto. dunder proto or __proto__ points to the prototype object of the constructor function.
        function Bike2(model,color){
          this.model = model,
          this.color = color
        }
        Bike2.prototype.getDetails = function(){
          return this.model + " bike is " + this.color;
        }
        var bikeObj21 = new Bike2('BMW','BLACK');
        var bikeObj22 = new Bike2('BMW','WHITE');
        console.log(bikeObj21.getDetails()); //output: BMW bike is BLACK
        console.log(bikeObj22.getDetails()); //output: BMW bike is WHITE
        console.log(bikeObj21,bikeObj22);
        // both bikeObj1 it's dunder proto or __proto__ property and Bike.prototype property is equal

        // No matter how many objects are created form a class the functions are loaded into memry only once and we can override functions if required using prototypes. 

        // Polymorphism is one of the tenets of Object-Oriented Programming (OOP). It is the practice of designing objects to share behaviors and to be able to override shared 
        // behaviors with specific ones. Polymorphism takes advantage of inheritance in order to make this happen.
        // sample code for an override a function in JavaScript:

        let F = function (){
            this.a = 1;
            this.b = 2;
        }
        let o = new F(); // {a: 1, b: 2}
        // add properties in F function's prototype
        F.prototype.b = 3;
        F.prototype.c = 4;
        // do not set the prototype F.prototype = {b:3,c:4}; this will break the prototype chain
        // o.[[Prototype]] has properties b and c.
        // o.[[Prototype]].[[Prototype]] is Object.prototype.
        // Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
        // This is the end of the prototype chain, as null,
        // by definition, has no [[Prototype]].
        // Thus, the full prototype chain looks like:
        // {a: 1, b: 2} ---> {b: 3, c: 4} ---> Object.prototype ---> null
        console.log(o.a); // 1   as a property is on o and is 1
        console.log(o.b); // 2   as a property is on o and is 2, if it wasngt would go further along the prottype chain to F's prototype and find o.b is 3
        // This is called Property Shadowing
        console.log(o.c); // 4  --> no .'c' property on o so go along the prototype chain and find one on o.[[Prototype]] whose value is 4
        console.log(o.d); // undefined. -->  No porperty found along the portotype chain -> end of chain is null. So undefined
        console.log(F.prototype);

        // Another simple example 
        function Moped(fName, lName){
            this.fName = fName;
            this.lName = lName;
        }
        Moped.prototype.getName = function() {
            return this.lName + " " + this.fName;
        }
        var tester = new Moped("John", "Reilly");
        console.log(tester.getName()); 
        tester.getName = function() {
            return "Property shadowing doesnt hoist " + this.fName + " " + this.lName   
        }
        console.log(tester.getName()); 
    
    // Classes 
        // Like syntaxtic sugar to make it easier to deal wth prototypes, i.e. creating methods 
        // Can also just create them using functions like done above 
        // Class declarations are not hoisted but function declarations are
        class Rectangle {
          constructor(height, width) {
            this.height = height;
            this.width = width;
          }
          // Getter
          get area() {
            return this.calcArea();
          }
          // Method
          calcArea() {
            return this.height * this.width;
          }
        }
        const square = new Rectangle(10, 10);
        console.log(square.area +"m^2"); // 100

        class Cuboid extends Rectangle {
            constructor(height, width, length) {
                super(height, width);
                this.length = length;
            }
            // Getter
            get area() {
                return this.calcArea();
            }
            //Method
            calcArea() {
                return this.height * this.width * this.length;
            }
        }
        const cub = new Cuboid(10,10,10);
        console.log(cub.area + "m^3");
        // Benefits of Using class
        // Convenient, self-contained syntax.
        // A single, canonical way to emulate classes in JavaScript. Prior to ES6, there were several competing implementations in popular libraries.
        // More familiar to people from a class-based language background.

    // Modules
        // a module is a small unit of independent, reusable code. Modules are the foundation of many JavaScript design patterns and are critically 
        // necessary when building any non-trivial JavaScript-based application.
        // JavaScript module export as the value rather than define a type, as JavaScript JavaScript module can export an object, Modules that export 
        // a string containing an HTML template or a CSS stylesheet are also common.
        // JavaScript doesn’t have private keyword but we can achieve private methods and properties using closures.
        var myModule = (function() {
            'use strict';

            var _privateProperty = 'Yabba Dabba Doo';
            function _privateMethod() {
                console.log(_privateProperty);
            }
            return {
                publicMethod: function() {
                    _privateMethod();
                }
            };
        }());
        
        myModule.publicMethod();                    // outputs 'Hello World'   
        console.log(myModule._privateProperty);     // is undefined as protected by the module closure
        //myModule._privateMethod();                  // is TypeError as protected by the module closure

    // Memoization
        // Memoization is a form of caching where the return value of a function is cached based on its parameters. 
        // If the parameter of that function is not changed, the cached version of the function is returned.
        // Example not including it:
        function addTo256(num){
            return num + 256;
        }

        addTo256(20); // Returns 276
        addTo256(40); // Returns 296
        addTo256(20); // Returns 276
        // When we are calling the function addTo256 again with the same parameter (“20” in the case above), we are computing the result again for the same parameter.
        // imagine if the function does some heavy duty work, then, computing the result again and again with the same parameter will lead to wastage of time.

        function memoizedAddTo256(){
            var cache = {};

            return function(num){
                if(num in cache){
                  console.log("cached value");
                  return cache[num]
                }
                else{
                  cache[num] = num + 256;
                  return cache[num];
                }
            }
        }

        var memoizedFunc = memoizedAddTo256();

        memoizedFunc(20); // Normal return
        memoizedFunc(20); // Cached return

        // **Note- Although using memoization saves time, it results in larger consumption of memory since we are storing all the computed results

    // Hoisting 
        // In javascript, you can call a function before it is defined and you won’t get an error ‘Uncaught ReferenceError’. The reason behind this 
        // is hoisting where the javascript interpreter always moves the variables and function declaration to the top of the current scope (function 
        // scope or global scope) before the code execution.
        cowSays('moo');  //No error as function declaration is hoisted 
        function cowSays(sound){
            console.log(sound);
        }
        // Class declarations are not hoisted but function declarations are

    // Scope 
        // Local Scope allow access to everything within the boundaries (inside the box)
        // Global Scope is everything outside the boundaries (outside the box). A global scope can not access a variable defined in local scope because it is 
        // enclosed from the outer world, except if you return it.

    // Closures
        // Is simply a function 
        // inside another function that has access to the outer function variable. Now, this definition sound pretty much straightforward but the real magic
        // is created with the scope. The inner function (closure) can access the variable defined in its scope (variables defined between its curly brackets),
        // in the scope of its parent function, and the global variables. Now here you need to remember that the outer function can not have access to the inner 
        // function variable (we have already discussed this in scope concept). Let’s take an example and understand it in a better way.
        const first = () => {
            const greet = "Hi";
            //console.log(name) // Note name is not in scope so blank output
            const second = () => {
                const name = 'john';
                console.log(greet); // Note greet is in scope 
            }
            //console.log(name) // Note name is not in scope so blank output 
            return second 
        }

        const newFunc = first();
        newFunc(); // Prints Hi 
        // In the above example, the inner function ‘second()’ is a Closure. This inner function will have access to the variable ‘greet’ which is the part of the
        // outer function ‘first()’ scope. Here the parent scope won’t have the access of child scope variable ‘name’.

        // Now the question is why do we need to learn closures? What’s the use of it? Closures are used when you want to extend behavior such as pass variables, 
        // methods, or arrays from an outer function to an inner function. In the above example, second() extends the behavior of the function first() and also 
        // has access to the variable ‘greet’. Javascript is not pure object-oriented language but you can achieve object-oriented behavior through closures. In 
        // the above example, you can think const ‘newFunc’ as an Object having property ‘greet’ and ‘second()’ a method as in an OOP language.

        // The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s 
        // variables, and it has access to the global variables.
        function User(name){
          var displayName = function(greeting){
            console.log(greeting+' '+name);
          }
          return displayName;
        }
        var myFunc = User('Raj');
        myFunc('Welcome '); //Output: Welcome Raj
        myFunc('Hello '); //output: Hello Raj
        // We have an outer function User() which returns an inner function as displayName(),
        // The inner function will have access to the variables in the outer function scope, even after the outer function has returned.

    // Currying 
        // In other words, when a function, instead of taking all arguments at one time, takes the first one and return a new function that takes the second one
        // and returns a new function which takes the third one, and so forth until all arguments have been fulfilled.
        var add =   function (a){
                    return function(b){
                        return function(c){
                                return a+b+c;
                                }        
                            }
                    }
        console.log(add(2)(3)(4)); //output 9
        console.log(add(3)(4)(5)); //output 12
        // Why Currying?
        // Mainly It helps to create a higher-order function. It is extremely helpful in event handling.
    </script>
</body>
</html>